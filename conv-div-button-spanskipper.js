// const conversionRulesList = [ { "":"", } ];

// const spanSkipperRuleSets = [ { "":"", } ];

function applyConversion(input, rules) { let result = ''; let i = 0; while (i < input.length) { let matched = false; for (let length = Math.min(Object.keys(rules).reduce((max, key) => Math.max(max, key.length), 0), input.length - i); length > 0; length--) { let substring = input.slice(i, i + length); if (substring in rules) { result += rules[substring]; i += length; matched = true; break; } } if (!matched) { result += input[i]; i++; } } return result; }

function applyWildcardConversion(input, rules) { for (const [pattern, replacement] of Object.entries(rules)) { if (pattern.includes('*')) { const [start, end] = pattern.split('*'); const regex = new RegExp(`${start}(.*?)${end}`, 'g'); input = input.replace(regex, (_, middle) => { if (replacement.includes('*')) { const [repStart, repEnd] = replacement.split('*'); return `${repStart}${middle}${repEnd}`; } else { return replacement; } }); } } return input; }

function updateOutput() { const inputText = document.getElementById('inputArea').value; const inputLines = inputText.split('\n'); const outputLines = inputLines.map(line => { const inputWords = line.split(' '); const outputWords = inputWords.map(word => { let convertedWord = word; for (const rules of conversionRulesList) { convertedWord = applyConversion(convertedWord, rules); convertedWord = applyWildcardConversion(convertedWord, rules); } return convertedWord; }); return outputWords.join(' '); }); document.getElementById('outputArea').innerHTML = outputLines.join('<br>'); }

function applyspanSkipperRuleSetsToText(text, spanSkipperRuleSets) { let modifiedText = text; spanSkipperRuleSets.forEach(rules => { for (const [key, value] of Object.entries(rules)) { const regex = new RegExp(key, 'g'); modifiedText = modifiedText.replace(regex, value); } }); return modifiedText; }

function processConversion() { const outputArea = document.getElementById('outputArea'); const spans = Array.from(outputArea.querySelectorAll('span')); let textContent = spans.map(span => span.textContent).join(''); spanSkipperRuleSets.forEach(rules => { for (const [input, output] of Object.entries(rules)) { let startIdx = textContent.indexOf(input); while (startIdx !== -1) { const endIdx = startIdx + input.length; let currentIndex = 0; let outputIndex = 0; let remainingOutput = output; spans.forEach(span => { const spanText = span.textContent; const spanStart = currentIndex; const spanEnd = currentIndex + spanText.length; if (startIdx >= spanStart && endIdx <= spanEnd) { span.textContent = spanText.slice(0, startIdx - spanStart) + output + spanText.slice(endIdx - spanStart); } else if (startIdx >= spanStart && startIdx < spanEnd) { const part1 = spanText.slice(0, startIdx - spanStart); const part2 = remainingOutput.slice(0, spanEnd - startIdx); span.textContent = part1 + part2; remainingOutput = remainingOutput.slice(spanEnd - startIdx); } else if (endIdx > spanStart && endIdx <= spanEnd) { const part1 = remainingOutput; const part2 = spanText.slice(endIdx - spanStart); span.textContent = part1 + part2; remainingOutput = ""; } else if (startIdx < spanStart && endIdx > spanEnd) { const part1 = remainingOutput.slice(0, spanEnd - spanStart); span.textContent = part1; remainingOutput = remainingOutput.slice(spanEnd - spanStart); } currentIndex += spanText.length; }); textContent = spans.map(span => span.textContent).join(''); startIdx = textContent.indexOf(input); } } }); }

document.getElementById('convertButton').addEventListener('click', function() { updateOutput(); processConversion(); });
